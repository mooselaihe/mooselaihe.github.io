<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>moose</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-05-15T04:46:04.161Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>mooselaihe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/05/17/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://example.com/2021/05/17/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</id>
    <published>2021-05-17T05:34:15.276Z</published>
    <updated>2021-05-15T04:46:04.161Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Java并发编程之美"><a href="#Java并发编程之美" class="headerlink" title="Java并发编程之美"></a>Java并发编程之美</h3><p>###1. 多线程的三种实现方式：</p><ol><li><p>继承Thread类</p></li><li><p>实现Runnable接口</p></li><li><p>Callable接口：  从最传统的开发来讲如果要进行多线程的实现肯定依靠的就是Runnable，但是<strong>Runnable接口有一个缺点</strong>：当线程执行完毕后，我们<strong>无法获取一个返回值</strong>，所以从JDK1.5之后就提出了一个新的线程实现接口：java.util.concurrent.Callable接口。</p><p>Callable多线程的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> x = <span class="number">0</span> ; x &lt; <span class="number">10</span> ; x ++ ) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;******线程执行，x = &quot;</span> + x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;线程执行完毕！&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        FutureTask futureTask = <span class="keyword">new</span> FutureTask(<span class="keyword">new</span> MyThread2());</span><br><span class="line">        <span class="keyword">new</span> Thread(futureTask).start();</span><br><span class="line">        System.out.println(<span class="string">&quot;线程返回值：&quot;</span> + futureTask.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><p>###2. 线程安全保证：</p><p>synchronized 同步锁：控制线程同步 同步锁 作用的是方法中参数里的对象</p><p>lock：锁，自己获得与释放</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lock.lock();<span class="comment">//获取锁对象</span></span><br><span class="line">lock.unlock();<span class="comment">//释放锁对象</span></span><br><span class="line"><span class="comment">//trylock()方法：lock在获取锁的时候拿不到就一直等待，trylock拿不到就返回false，停止等待</span></span><br></pre></td></tr></table></figure><p>###3. 乐观锁与悲观锁（CAS，synchronized）：</p><ul><li><p>synchronized是悲观锁，这种线程一旦得到锁，其他需要锁的线程就挂起的情况就是悲观锁。</p></li><li><p>CAS操作的就是乐观锁（比较并替换），每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。</p><ul><li><p>CAS机制当中使用了3个基本操作数：内存地址V，旧的预期值A，要修改的新值B。</p><p>更新一个变量的时候，只有当变量的预期值A和内存地址V当中的实际值相同时，才会将内存地址V对应的值修改为B。</p></li><li><p>CAS实现原子操作的三大问题</p><ol><li><p>ABA问题：一个值原来是A，变成了B，又变成了A，使用CAS进行检查时无法发现值的变化</p><p>解决思路：使用版本号A-&gt;B-&gt;A,变成1A-&gt;2B-&gt;3A,来进行双重检查检查当前引用是否等于预期引用，检查当前标志是否等于预期标志。</p></li><li><p>循环时间开销大</p></li><li><p>只能保证一个共享变量的原子操作</p><p>解决思路：使用锁机制来实现原子操作，偏向锁，轻量级锁</p></li></ol></li></ul></li><li><p>CAS的缺点：</p><p>1.CPU开销较大<br> 在并发量比较高的情况下，如果许多线程反复尝试更新某一个变量，却又一直更新不成功，循环往复，会给CPU带来很大的压力。</p><p>2.不能保证代码块的原子性<br> CAS机制所保证的只是一个变量的原子性操作，而不能保证整个代码块的原子性。比如需要保证3个变量共同进行原子性的更新，就不得不使用Synchronized了。</p></li></ul><p>  链接：<a href="https://www.jianshu.com/p/ae25eb3cfb5d">https://www.jianshu.com/p/ae25eb3cfb5d</a></p><h3 id="4-守护线程和用户线程"><a href="#4-守护线程和用户线程" class="headerlink" title="4. 守护线程和用户线程"></a>4. 守护线程和用户线程</h3><p><strong>守护线程 Daemon Thread</strong>：主要被作用程序中后台调度以及支持性工作</p><p>GC垃圾回收就是一个标准的守护线程</p><p>特点：在所有用户线程执行结束后，守护线程和虚拟机一起关闭。</p><h3 id="5-并发编程中数据安全问题（Java并发采用的是共享内存模型-JMM）"><a href="#5-并发编程中数据安全问题（Java并发采用的是共享内存模型-JMM）" class="headerlink" title="5. 并发编程中数据安全问题（Java并发采用的是共享内存模型-JMM）"></a>5. 并发编程中数据安全问题（Java并发采用的是共享内存模型-JMM）</h3><p>全面理解java内存模型  <a href="https://blog.csdn.net/suifeng3051/article/details/52611310">https://blog.csdn.net/suifeng3051/article/details/52611310</a></p><p><strong>原子性</strong>是指在一个操作中就是cpu不可以在中途暂停然后再调度，既不被中断操作，要不执行完成，要不就不执行。</p><p><strong>可见性</strong>是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p><p><strong>有序性</strong>即程序执行的顺序按照代码的先后顺序执行。</p><blockquote><p><strong>原子性</strong>：Java内存模型直接保证原子性变量操作包括：read，load，assign，use，store，write</p><p><strong>可见性</strong>：volatile，synchronized，final</p><p><strong>有序性</strong>：**如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有操作都是无序的；后半句是指==指令重排序现象和工作内存有主内存同步延迟==**；</p><p>补充：</p><ol><li><p>先行先发生原则(Happens-Before)</p><p>内容：先行发生是Java内存模型中定义的两项操作之间的偏序关系</p><p>作用：可以用来判断数据是否存在竞争，线程是否安全</p></li></ol></blockquote><p><strong>JMM是一种规范，目的是解决由于多线程通过共享内存进行通信时，存在的本地内存数据不一致、编译器会对代码指令重排序、处理器会对代码乱序执行等带来的问题。</strong></p><h4 id="5-1-内存模型"><a href="#5-1-内存模型" class="headerlink" title="5.1 内存模型"></a>5.1 内存模型</h4><p><strong>java内存模型</strong></p><p>上面讲到了Java线程之间的通信采用的是过共享内存模型，这里提到的共享内存模型指的就是Java内存模型(简称JMM)，<strong>JMM决定一个线程对共享变量的写入何时对另一个线程可见</strong>。从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：<strong>线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本</strong>。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。</p><p>java线程之间的通信采用的是共享内存模型。共享变量放入主内存中，每个线程都有一个私有的本地内存，存放共享变量的副本，当线程要通信时（关于共享变量）</p><ul><li><p>首先，线程A把本地内存A中更新过的共享变量刷新到主内存中去。</p></li><li><p>然后，线程B到主内存中去读取线程A之前已更新过的共享变量。 </p></li></ul><p><strong>JMM通过控制主内存与每个线程的本地内存之间的交互，来为java程序员提供内存可见性保证。</strong></p><p>####5.2 JVM对Java内存模型的实现</p><p>在Jvm内部，java内存模型把内存分为两个部分：线程栈区，堆区</p><p>当对象和变量存储到计算机的各个内存区域时，必然会面临一些问题，其中最主要的两个问题是：</p><blockquote><ol><li><p>共享对象对各个线程的可见性</p></li><li><p>共享对象的竞争现象</p></li></ol></blockquote><p>为了保证内存可见性，java编译器在生成指令序列的适当位置插入内存屏障来禁止特定类型的处理器重排序</p><p> 真正理解Java Volatile的妙用:<a href="https://www.jianshu.com/p/c9c77d771">https://www.jianshu.com/p/c9c77d771</a> 221</p><p><strong>JVM对正确同步的多线程程序的内存一致性有如下保证：</strong></p><p><strong>顺序一致性：程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同</strong></p><p>顺序一致性内存模型：所有操作之间具有全序关系</p><ol><li><p>一个线程中的所有操作必须按照程序的顺序执行</p></li><li><p>所有线程都只能看到一个单一的操作执行顺序。每个操作都必须原子执行且立刻对所有线程可见</p></li></ol><p><strong>volatile型变量</strong>的特殊规则：</p><ol><li><p>保证可见性：主内存与工作内存之间的交互分为8个原子操作分别是lock,unlock,read,load,assign,use,store,write。</p></li><li><p>不保证原子性:</p></li><li><p>禁止指令重排序（内存屏障）</p><ul><li><p>什么是指令重排序：机器级的优化操作</p><blockquote><p>源代码–&gt;编译器优化的重排–&gt;指令并行的重排–&gt;内存系统的重排–&gt;最终执行的指令</p></blockquote></li></ul></li></ol><ul><li>最轻量级的同步机制<ul><li>使用之前必须先从主内存刷新最新的值，保证能看见其他线程对主内存变量的修改</li><li>每次修改以后都立刻同步回主内存，保证其他线程可以看到自己对主内存变量的修改</li></ul></li><li>两项特性：1. 可见性，2. 一致性</li><li>关于原子性：对任意单个volatile变量读/写具有原子性，类似于volatile++这种复合操作不具有原子性</li></ul><h3 id="6-线程安全和锁优化"><a href="#6-线程安全和锁优化" class="headerlink" title="6.线程安全和锁优化"></a>6.线程安全和锁优化</h3><p>线程安全定义：当多个线程同时访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那就称这个对象是线程安全的。</p><p>####线程安全</p><p>把Java语言中各种操作共享的数据分为五类：不可见，绝对线程安全，相对线程安全，线程兼容和线程对立</p><ol><li>不可见</li><li>绝对线程安全：</li><li>相对线程安全：保证对这个对象单次的操作是线程安全的</li><li>线程兼容：指对象本身不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全的使用</li><li>线程对立：</li></ol><h4 id="线程安全的实现方法"><a href="#线程安全的实现方法" class="headerlink" title="线程安全的实现方法"></a><strong>线程安全的实现方法</strong></h4><ol><li><p>互斥同步：阻塞同步（synchronized）悲观的并发策略</p><p>问题：面临的主要问题是线程阻塞和唤醒所带来的性能消耗（OS用户态-&gt;系统态之间的切换——软中断）</p></li><li><p>非阻塞同步：基于冲突检测的乐观并发策略 无锁编程</p><blockquote><p>需要‘’硬件指令集的发展‘’ 操作和冲突检测两个步骤具有原子性</p><ol><li>测试并设置（Test-and-Set）</li><li>获取并增加（Fetch-and-Increment）</li><li>交换（Swap）</li><li>比较并交换 CAS</li><li>加载链接</li></ol></blockquote></li><li><p>无同步方案：线程安全与同步并没有必然的联系。同步只是保障存在共享数据竞争时正确性的手段，不涉及到共享数据，就不需要任何同步策略保证其正确性</p></li></ol><h4 id="锁优化：在线程之间更高效地共享数据及解决竞争问题，从而提高程序的执行效率"><a href="#锁优化：在线程之间更高效地共享数据及解决竞争问题，从而提高程序的执行效率" class="headerlink" title="锁优化：在线程之间更高效地共享数据及解决竞争问题，从而提高程序的执行效率"></a>锁优化：在线程之间更高效地共享数据及解决竞争问题，从而提高程序的执行效率</h4><p><strong>自旋锁和自适应自旋</strong>：忙等一个周期</p><p><strong>锁消除</strong>：虚拟机即时编译器在运行时检测到某段需要同步的代码根本不可能存在共享数据竞争而实施的一种对锁进行消除的优化策略:判断依据逃逸分析</p><p><strong>锁粗化</strong>：</p><h4 id="锁的对比"><a href="#锁的对比" class="headerlink" title="锁的对比"></a>锁的对比</h4><p><strong>偏向锁</strong>：</p><p><strong>轻量级锁</strong>：设计初衷：在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗</p><h3 id="7-java并发编程基础"><a href="#7-java并发编程基础" class="headerlink" title="7.java并发编程基础"></a>7.java并发编程基础</h3><h4 id="7-1使用多线程的目的："><a href="#7-1使用多线程的目的：" class="headerlink" title="7.1使用多线程的目的："></a>7.1使用多线程的目的：</h4><ol><li>更多的处理器核心</li><li>更快的响应时间：把数据一致性不强的操作派发给其他线程处理</li><li>更好的编程模型</li></ol><h4 id="7-2线程的状态："><a href="#7-2线程的状态：" class="headerlink" title="7.2线程的状态："></a>7.2线程的状态：</h4><h4 id="7-3线程间通信："><a href="#7-3线程间通信：" class="headerlink" title="7.3线程间通信："></a>7.3线程间通信：</h4><p>通过对主内存的共享变量进行修改来进行隐式通信</p><p><strong>volatile和synchronized关键字</strong></p><p>每一个对象都有自己的监视器</p><p><strong>等待/通知机制</strong></p><p>等待/通知经典范式：加锁、条件循环和处理逻辑</p><p>等待方遵循如下范式：</p><ol><li>获取对象的锁</li><li>如果条件不满足，那么调用对象的wait()方法，被通知后仍要检查条件。</li><li>条件满足，执行相关业务逻辑</li></ol><p>通知方遵循如下范式：</p><ol><li>获取对象的锁</li><li>改变条件</li><li>通知所有等待在对象上的线程（从等待队列进入同步队列）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">synchronized(对象)&#123;</span><br><span class="line">while(条件不满足)&#123;</span><br><span class="line">对象.wait();</span><br><span class="line">&#125;</span><br><span class="line">对应的处理逻辑</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">synchronized(对象)&#123;</span><br><span class="line">改变条件</span><br><span class="line">对象.notifyAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Thread.join()的使用</strong></p><p>如果线程A执行了thread.join()语句，当线程A等带thread线程终止后从thread.join()返回</p><h3 id="8-java中的锁"><a href="#8-java中的锁" class="headerlink" title="8.java中的锁"></a>8.java中的锁</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Java并发编程之美&quot;&gt;&lt;a href=&quot;#Java并发编程之美&quot; class=&quot;headerlink&quot; title=&quot;Java并发编程之美&quot;&gt;&lt;/a&gt;Java并发编程之美&lt;/h3&gt;&lt;p&gt;###1. 多线程的三种实现方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;继承Th</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>java</title>
    <link href="http://example.com/2021/05/17/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <id>http://example.com/2021/05/17/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</id>
    <published>2021-05-17T04:58:33.000Z</published>
    <updated>2021-05-17T04:59:05.627Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java网络编程"><a href="#Java网络编程" class="headerlink" title="Java网络编程"></a>Java网络编程</h1><h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java网络编程&quot;&gt;&lt;a href=&quot;#Java网络编程&quot; class=&quot;headerlink&quot; title=&quot;Java网络编程&quot;&gt;&lt;/a&gt;Java网络编程&lt;/h1&gt;&lt;h3 id=&quot;Socket&quot;&gt;&lt;a href=&quot;#Socket&quot; class=&quot;headerli</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2021/05/17/hello-world/"/>
    <id>http://example.com/2021/05/17/hello-world/</id>
    <published>2021-05-17T02:52:23.845Z</published>
    <updated>2021-05-17T02:52:23.845Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
